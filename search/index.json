[{"content":"Pointers Basics Pointers a way of referring to the location of a variable the value of a pointer is the location of another variable (can think of the location as an arrow that points to another variable)\n1 2 3 4 +------------------+ +--------------------+ | p (pointer) | -----\u0026gt; | x (int) | | value: \u0026amp;x | | value: 10 | +------------------+ +--------------------+ Declaring a pointer pointer is not a type. Pointer is a type constructor\u0026ndash;a language construct (when applied to another type, give us a new type)\nexample: char *x{.verbatim} means \u0026quot;pointer to a char\u0026quot;\nSyntax\nchar * mycharpointer\nsymbol *{.verbatim}\nadding *{.verbatim} after any type names makes it a \u0026quot;pointer to that type\u0026quot;\nPurpose\ntell us the variable name and the type of variable that the pointer will point to.\nAssigning to a pointer pointer can be assigned and changing their values (as with all other varibles)\nchanging the value of a pointer changes the memory location it points to\ninitialize pointers before use (the first time assigning)\nundefined pointers point to unknown memory locations, causing undefined behavior and possible program crashes\nassigning an address to a pointer\nhave a variable (a 'box' in memory)\nget its address using the \u0026amp;\nassign that address to the pointer\n1 2 3 int x = 5; // variable int *xPtr; // declare the pointer xPtr = \u0026amp;x; // assign the pointer, store x\u0026#39;s address in xPtr \u0026amp;{.verbatim} operator behavior\n\u0026amp;{.verbatim} is called an \u0026quot;ampersand\u0026quot; \u0026amp;{.verbatim} gives an arrow pointing at its operand1(the memory location of the operand) \u0026amp;{.verbatim} can be applied to any lvalue (an expression that refers to a memory location). for variables, \u0026amp;x{.verbatim} means \u0026ldquo;the address of x\u0026rdquo;. the address of a variable is not itself an lvalue → you can\u0026rsquo;t change it. \u0026amp;x = 5{.verbatim}; is invalid. Unary vs. binary operator\nComparison Unary \u0026amp; (address-of) Binary \u0026amp; (bitwise AND)\nNumber of operands 1 2 Result type pointer integer (bitwise result) Purpose Get the memory address of a variable Perform bitwise AND on two integers Example p = \u0026amp;x; c = a \u0026amp; b;\n1 2 3 4 5 6 7 8 // Example for address-of int x = 5; int *p = \u0026amp;x; // Example for bitwise AND int a = 3; // Binary 0110 a = 0 1 1 0 int b = 5; // Binary 1010 b = 1 0 1 0 int c = a \u0026amp; b;// The result is 0010 (binary),which is 2 a \u0026amp; b = 0 0 1 0 Dereferencing a pointer using *{.verbatim} to access/change the value stored at the memory location a pointer points to two meanings of *{.verbatim} declaration: int *p{.verbatim} → pointer to int expression: *p{.verbatim} → dereference 1 2 3 int x = 5; // x = 5 int *p = \u0026amp;x; // pointer initialized with x’s address *p = 6; // x = 6 (dereference to modify x) Pictures When working with pointers, always draw pictures to help you.\ndraw a box with the name on the left and the value of the variable on the right. (The uninitialized value can be represented with a \u0026lsquo;?\u0026rsquo;) +\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | x | 5 | | xPtr | ? | | xPtr | 0x1000 | \u0026lt;- Address of x（x的地址） +\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ arrow +\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | x | 5 | \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | xPtr | 0x1000 | +\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ the image in coursera\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void g(int x, int * y) { printf(\u0026#34;In g, x = %d, *y = %d\\n\u0026#34;, x, *y); x++; *y = *y - x; // change the value of *y, aka b y = \u0026amp;x; // do not change b, change y } void f(int * a, int b) { printf(\u0026#34;In f, *a = %d, b = %d\\n\u0026#34;, *a, b); *a += b; b *= 2; g(*a, \u0026amp;b); printf(\u0026#34;Back in f, *a = %d, b = %d\\n\u0026#34;, *a, b); // output b, not y } int main(void) { int x = 3; int y = 4; f(\u0026amp;x, y); printf(\u0026#34;In main: x = %d, y = %d\\n\u0026#34;, x, y); //*a change the value of x, y does not change return EXIT_SUCCESS; } 1 2 3 4 5 #+RESULTS: In f, *a = 3, b = 4 In g, x = 7, *y = 8 Back in f, *a = 7, b = 0 In main: x = 7, y = 4 diagram Footnotes operand: 运算对象\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-08-14T09:50:13+08:00","permalink":"https://csq-an94.github.io/p/pointers_arrays_and_recursion/","title":"Pointers_arrays_and_recursion"},{"content":"开始尝试第一篇blog，希望一切顺利。还没太搞懂这个博客的设置，现在完全是毛坯房，下面可能会尝试上传我的笔记试试看。\n","date":"2025-08-11T18:13:54+08:00","permalink":"https://csq-an94.github.io/p/myfirstblog/","title":"MyFirstBlog"}]