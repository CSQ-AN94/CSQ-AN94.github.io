[{"content":":ID: 369b629d-2991-4961-9234-83a00b87ecc5\nRUNNING compiling process preprocessing 预处理\nmain.c → main.i\ndeal with #include deal with conditional directives 1(e.g. #if) delete #define,expand all the macos delete all comments add line and dile markers, so debug symbols and error/warning messages report correct locations keep all #pragma directives compilation 编译\nmain.c → main.s\nLexical analysis 词法分析 Syntax analysis 语法分析 Semantic analysis 语义分析 Optimization 优化 assembly 汇编\nmain.c → main.o Translates assembly instructions(汇编指令) into machine code\nlinking\nmain.o + licraries → a.out\nStatic Linking 静态链接 Dynamic Linking 动态链接 picture of the hole process\ntools compiling (GCC) 「References: GCC(MinGW)使用入门教程」\n命令\n格式: gcc \u0026lt;options\u0026gt; \u0026lt;source-files\u0026gt; \u0026ndash; gcc \u0026lt;source-files\u0026gt; \u0026lt;options\u0026gt; // gcc \u0026lt;options\u0026gt; \u0026lt;source-files\u0026gt; \u0026lt;option\u0026gt; is ok\noptions\nOption English Description 中文说明 Example -o \u0026lt;file\u0026gt; Specify output file name 指定输出文件名 gcc -o app main.c -Wall Enable warning messages 开启常见警告 gcc -Wall main.c -o app -fexec-charset=\u0026lt;charset\u0026gt; Set execution character set 指定运行时编码 gcc -fexec-charset=GBK main.c -o app -finput-charset=\u0026lt;charset\u0026gt; Set source file input character set 指定源文件编码 gcc -finput-charset=UTF-8 main.c -o app -O0 … -O3 Set optimization level (0 to 3) 指定优化级别（0~3） gcc -O2 main.c -o app -E + -o \u0026lt;file.i\u0026gt; Run preprocessing only; write output to file 仅预处理，配合 -o 写入 .i 文件 gcc -E -o out.i main.c -S Compile to assembly only 仅编译到汇编（生成 .s，不汇编不链接） gcc -S -o out.s main.c -c Compile to object code only (no linking) 仅生成目标文件 .o（不链接） gcc -c -o main.o main.c -static Link statically 静态链接 gcc -static main.c -o app -I\u0026lt;dir\u0026gt; Add directory to header search path 增加头文件搜索路径 gcc -Iinclude src/main.c -o app -L\u0026lt;dir\u0026gt; Add directory to library search path 增加库搜索路径 gcc -Llib main.c -lm -o app -W\nBasic Syntax\nWxxx wnable a specific warning Wno-xxx disable a specific warning Werror2 treat all warnings as erroes Werror treat only the specified warning as an error Common Warning Options Option Description -Wall Enable most common warnings (not all) -Wextra Enable extra warnings in addition to -Wall -Wunused-variable Warn about unused variables -Wsign-compare Warn when comparing signed and unsigned integers -Wreturn-local-addr Warn if returning the address of a local variable -Werror Treat all warnings as errors -Werror=xxx Treat only a specific warning as an error -Wno-xxx Disable a specific warning Example\n1 2 3 4 5 6 7 8 9 gcc -o main -Wall main.c # Enable common warnings + treat returning local address as an error gcc -o main -Wall -Wextra -Werror=return-local-addr main.c # Disable unused variable warning gcc -o main -Wall -Wno-unused-variable main.c # Treat all warnings as errors gcc -o main -Wall -Wextra -Werror main.c -I\u0026lt;dir\u0026gt;\nbasic usage\ngcc -I\u0026lt;path\u0026gt; source.c -o output \u0026lt;path\u0026gt; can be absolute or relative\nrelative vs. absolute paths\nrelative\n1 2 gcc -Iinclude -o main main.c # searches ./include/ ./ → current directory gcc -I../include -o main main.c # searches ../include/ ../ → parent directory absolute\n1 2 3 4 5 6 #Linux/macOS gcc -I/home/user/project/include -o main main.c #Windows gcc -IC:\\Users\\SKK\\Desktop\\GCC\\03\\include -o main main.c #if the path contains spaces(空格), wrap it in quotes gcc -I\u0026#34;C:\\Users\\SKK\\Desktop\\GCC\\03\\my include\u0026#34; -o main main.c multiple paths\n1 gcc -Iinclude -I../common/include -I\u0026#34;C:\\extra\\include\u0026#34; -o main main.c -g\npurpose\nAdds debugging information (function names, line numbers, variable names) to the executable. Allows debuggers like gdb or lldb to show source code locations and variable values. common levels\n-g or -g2 Default debug info, most common -g1 Minimal info (function names, line numbers only) -g3 Extra info (includes macro definitions -g0 No debug info (disables debugging) common usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Normal debugging gcc -g -o main main.c # Maximum debug info gcc -g3 -o main main.c # Debugging + disable optimizations (easier to debug) gcc -g -O0 -o main main.c # Debugging + enable optimizations (faster, but may misalign with source lines) gcc -g -O2 -o main main.c # Use with -W gcc -g -O0 -Wall -o app main.c multi-file compilation\ncompile \u0026amp; link in one step\n1 gcc -o main main.c bubblesort.c or\n1 gcc -o main *.c Compile separately, then link\n1 2 3 gcc -c main.c gcc -c bubblesort.c gcc -o main main.o bubblesort.o Next: automate with Makefile skip v\nmakefile 「References: 20分钟Makefile光速入门教程」\nrule\n1 2 target : dependencies \u0026lt;TAB\u0026gt;action target (the file you want to build/目标文件) e.g. main.o, hello dependencies (files required to build the target) such as .c source files or head files If any dependency changes, make will automatically rebuild the target. action (shell command(s) to build the target/执行文件) must start with a Tab 1 2 main:main.c message.c gcc -o main main.c message.c timestamp based rebuild\nlogic\nif any dependency is newer than the target → rebuild the target if target does not exist → build it if dependencies are older than the target → skip rebuilding example\nSingle-step build\n1 2 main:main.c message.c gcc -o main main.c message.c dependencies：main.c message.c logic: if any .c is newer than hello → rebuild the whole program drawback: even one changed .c forces all sources to recompile and link multi-step build\n1 2 3 4 5 6 7 8 main: main.o message.o gcc -o main main.o message.o main.o: main.c gcc -c main.c message.o: message.c gcc -c message.c dependencies hello → .o files each .o → its own .c file logic: only changed .c files are recompiled; then linking runs once advantage: faster incremental builds, avoids unnecessary recompilation directives:指令\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n| Warning | Error | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-| | Potential issue, program can still compile | Serious issue, compilation stops | | May cause bugs at runtime | Must fix before running | | Example: unused variable | Example: missing ; |\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-08-14T11:26:01+08:00","permalink":"https://csq-an94.github.io/p/writing_running_and_fixing_code_in_c/","title":"Writing_Running_and_Fixing_Code_in_C"},{"content":"Pointers Basics Pointers a way of referring to the location of a variable the value of a pointer is the location of another variable (can think of the location as an arrow that points to another variable)\n1 2 3 4 +------------------+ +--------------------+ | p (pointer) | -----\u0026gt; | x (int) | | value: \u0026amp;x | | value: 10 | +------------------+ +--------------------+ Declaring a pointer Pointer is not a type. Pointer is a type constructor\u0026ndash;a language construct (when applied to another type, give us a new type) example: `char *x` means \\\u0026quot;pointer to a char\\\u0026quot; Syntax char \\* my_charpointer Symbol * adding `*` after any type names makes it a \\\u0026quot;pointer to that type\\\u0026quot; Purpose tell us the variable name and the type of variable that the pointer will point to. Assigning to a pointer pointer can be assigned and changing their values (as with all other varibles) changing the value of a pointer changes the memory location it points to initialize pointers before use (the first time assigning) undefined pointers point to unknown memory locations, causing undefined behavior and possible program crashes assigning an address to a pointer 1. have a variable (a \\'box\\' in memory) 2. get its address using the \u0026amp; 3. assign that address to the pointer ``` c int x = 5; // variable int *xPtr; // declare the pointer xPtr = \u0026amp;x; // assign the pointer, store x's address in xPtr ``` \u0026amp; operator behavior - `\u0026amp;` is called an \\\u0026quot;ampersand\\\u0026quot; - `\u0026amp;` **gives an arrow pointing at** its operand[^1](the memory location of the operand) - `\u0026amp;` can be applied to any lvalue (an expression that refers to a memory location). - for variables, `\u0026amp;x` means \u0026quot;the address of x\u0026quot;. - **the address of a variable is not itself an lvalue → you can't change it.** `\u0026amp;x = 5`; is invalid. Unary vs. binary operator | Comparison | Unary `\u0026amp;` (address‑of) | Binary `\u0026amp;` (bitwise AND) | |-------------------|-----------------------------------|------------------------------------| | Number of operands| 1 | 2 | | Result type | **pointer** | **integer** (bitwise result) | | Purpose | Get the memory address of a variable | Perform bitwise AND on two integers | | Example | `p = \u0026amp;x;` | `c = a \u0026amp; b;` | ``` c // Example for address-of int x = 5; int *p = \u0026amp;x; // Example for bitwise AND int a = 3; // Binary 0110 a = 0 1 1 0 int b = 5; // Binary 1010 b = 1 0 1 0 int c = a \u0026amp; b;// The result is 0010 (binary),which is 2 a \u0026amp; b = 0 0 1 0 ``` Dereferencing a pointer using * to access/change the value stored at the memory location a pointer points to two meanings of * declaration: int *p → pointer to int expression: *p → dereference 1 2 3 int x = 5; // x = 5 int *p = \u0026amp;x; // pointer initialized with x’s address *p = 6; // x = 6 (dereference to modify x) Pictures When working with pointers, always draw pictures to help you.\n1 2 3 4 5 6 7 8 1. draw a box with the name on the left and the value of the variable on the right. (The uninitialized value can be represented with a \u0026#39;?\u0026#39;) +-------+-------+ +--------+-----------+ +--------+-----------+ | x | 5 | | xPtr | ? | | xPtr | 0x1000 | \u0026lt;- Address of x（x的地址） +-------+-------+ +--------+-----------+ +--------+-----------+ 2. arrow +-------+-------+ +--------+----------------------+ | x | 5 | \u0026lt;------------ | xPtr | 0x1000 | +-------+-------+ +--------+----------------------+ the image in coursera\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void g(int x, int * y) { printf(\u0026#34;In g, x = %d, *y = %d\\n\u0026#34;, x, *y); x++; *y = *y - x; // change the value of *y, aka b y = \u0026amp;x; // do not change b, change y } void f(int * a, int b) { printf(\u0026#34;In f, *a = %d, b = %d\\n\u0026#34;, *a, b); *a += b; b *= 2; g(*a, \u0026amp;b); printf(\u0026#34;Back in f, *a = %d, b = %d\\n\u0026#34;, *a, b); // output b, not y } int main(void) { int x = 3; int y = 4; f(\u0026amp;x, y); printf(\u0026#34;In main: x = %d, y = %d\\n\u0026#34;, x, y); //*a change the value of x, y does not change return EXIT_SUCCESS; } 1 2 3 4 5 #+RESULTS: In f, *a = 3, b = 4 In g, x = 7, *y = 8 Back in f, *a = 7, b = 0 In main: x = 7, y = 4 diagram Footnotes ","date":"2025-08-14T09:50:13+08:00","permalink":"https://csq-an94.github.io/p/pointers_arrays_and_recursion/","title":"Pointers_arrays_and_recursion"},{"content":"开始尝试第一篇blog，希望一切顺利。还没太搞懂这个博客的设置，现在完全是毛坯房，下面可能会尝试上传我的笔记试试看。\n","date":"2025-08-11T18:13:54+08:00","permalink":"https://csq-an94.github.io/p/myfirstblog/","title":"MyFirstBlog"}]